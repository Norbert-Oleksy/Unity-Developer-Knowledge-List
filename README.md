I want to create a list of things that can be learned related to Unity.

# 1. Programing
## 1.1. C#
### 1.1.1. Variables
- [ ] Types of Variables
- [ ] Logical Operators
- [ ] Concatination and Interpolation
- [ ] Converting
- [ ] Increment and Decrement
- [ ] Enum
- [ ] Fields
- [ ] Properties

### 1.1.2. Control Flow
- [ ] If Statements
- [ ] Switch
- [ ] Ternary Operators
- [ ] Exception Handling (try/catch/finally)

### 1.1.3. Collections
- [ ] Arrays
- [ ] Lists
- [ ] Dictionaries
- [ ] HashSet
- [ ] Queue / Stack
- [ ] IEnumerable

### 1.1.4. Loops
- [ ] For
- [ ] While
- [ ] Foreach
- [ ] Break / Continue

### 1.1.5. Functions
- [ ] Arguments
- [ ] Return Types
- [ ] Ref and Out
- [ ] Overload
- [ ] Params
- [ ] Optional Parameters
- [ ] Local Functions
- [ ] Lambda Expressions
- [ ] Generic Methods
- [ ] Tuples
- [ ] Extension Methods

### 1.1.6. Class
- [ ] Access Modifiers
- [ ] Constructor and Destructor
- [ ] Static vs Instance Members
- [ ] This Keyword
- [ ] Object Initializers
- [ ] Inheritance
- [ ] Virtual / Override
- [ ] Abstract Classes
- [ ] Interfaces
- [ ] Polymorphism
- [ ] Hiding
- [ ] Generic Classes

### 1.1.7. Delegates
- [ ] Delegates
- [ ] Events
- [ ] Action / Func / Predicate
- [ ] Multicast Delegates

### 1.1.8. LINQ
- [ ] Select / Where / First
- [ ] ToList, Any, All
- [ ] OrderBy / ThenBy
- [ ] GroupBy

### 1.1.9. Asynchronous Programming
- [ ] Async / Await
- [ ] Task
- [ ] CancellationToken
- [ ] Delay, Wait, Result
- [ ] Coroutine
- [ ] UniTask

### 1.1.10. Serialization
- [ ] JSON (System.Text.Json / Newtonsoft)
- [ ] Binary Serialization
- [ ] XML Serialization
- [ ] Unity's `JsonUtility`

## 1.2. Clean Code
### 1.2.1. Good Manners in C#
- [ ] Naming Convention
- [ ] Order of Items in Classes

### 1.2.2. SOLID
- [ ] Single Responsibility Principle
- [ ] Open-closed Principle
- [ ] Liskov Subsititution Principle
- [ ] Interface Segregation Principle
- [ ] Dependency Inversion Principle

### 1.2.3. Design Patterns
- [ ] Strategy
- [ ] Observer
- [ ] Command
- [ ] State
- [ ] Decorator
- [ ] Facade
- [ ] Abstract Factory
- [ ] Singleton
- [ ] Object Pool
- [ ] Service Locator
- [ ] Visitor

### 1.2.4. Object-Oriented Principles (OOP)
- [ ] Don't Repeat Yourself
- [ ] Abstraction
- [ ] Polymorphism
- [ ] Inheritance
- [ ] Encapsulation
- [ ] Relationships Between Classes

## 1.3. Architecture
- [ ] Finite-State Machine (FSM)
- [ ] MVC / MVVM / MVP
- [ ] Entity-Component-System (ECS)
- [ ] Dependency Injection

## 1.4. Game Mathematice
- [ ] Vector
- [ ] Linear Algebra
- [ ] Euler Angle
- [ ] Quaternion
- [ ] Curvers

## 1.5. Procedural Generation
- [ ] Perlin Noise
- [ ] Simplex Noise
- [ ] Chunk-Based Generation
- [ ] Wave Function Collapse
- [ ] Randomization Techniques
- [ ] Noise-Based Terrain

# 2. Visual
## 2.1. User Interface
### 2.1.1. Canva

### 2.1.2. UI Toolkit

## 2.2. Light
### 2.2.1. Types of Light

### 2.2.2. Reflections

### 2.2.3. Shadows

## 2.3. Shaders
### 2.3.1. Shader Graph

### 2.3.2. CG

### 2.3.3. GLSL

### 2.3.4. HLS

## 2.4. Animations
### 2.4.1. Animation Clip

### 2.4.2. Animator
- [ ] Animator Parameters
- [ ] Blend Tree

### 2.4.3. Timeline

### 2.4.4. DOTween

### 2.4.5. Cinemachine

## 2.5. Particle System

## 2.6. Render Pipelines
### 2.6.1. Scriptable Render Pipeline (SRP)

### 2.6.2. Universal Render Pipeline (URP)

### 2.6.3. High Definition Render Pipeline (HDRP)

## 2.7. 2D
- [ ] Mask
- [ ] Tilemap
- [ ] Sprite

## 2.8. 3D
- [ ] LOD
- [ ] Terrain Tool
- [ ] ProBuilder
- [ ] Splines

# 3. Audio
## 3.1. Audio Source

## 3.2. Audio Mixer

## 3.3. Other
### 3.3.1. Fmod

### 3.3.2. Wwise

# 4. Unity
## 4.1. Unity Concept
### 4.1.1. Editor
- [ ] Hierarchy
- [ ] Project
- [ ] Inspector
- [ ] Attributes
- [ ] Custom Editor

### 4.1.2. Assets
- [ ] Textures
- [ ] Meshes
- [ ] Materials
- [ ] Sprite
- [ ] Prefabs
- [ ] Prefabs Variants
- [ ] Nested Prefabs
- [ ] GameObject
- [ ] scene

## 4.2. Physics
- [ ] Collider
- [ ] Rigidbody
- [ ] Physical layers
- [ ] Colider
- [ ] Joint
- [ ] Ragdol
- [ ] Raycast
- [ ] Overlaps

## 4.3. Tools
### 4.3.1. New Input System

### 4.3.2. Unity Job System

### 4.3.3. Support Tools

### 4.3.4. Analytics Tools

### 4.3.5. Ads Tools

## 4.4. Game AI
### 4.4.1. Finite-state machine

### 4.4.2. Behaviour tree

### 4.4.3. Utility AI

### 4.4.4. Machine Learning (Unity ML)

### 4.4.4. Finding a path
- [ ] Navmesh
- [ ] Pathdifinging

# 5. Gameplay Systems
## 5.1. Reusable Systems
### 5.1.1. First Person Controller

### 5.1.2. Third Person Controller

### 5.1.3. Save System
- [ ] To File (JSON)
- [ ] Player Prefs
- [ ] Cloud Save

### 5.1.4. Quest System

### 5.1.5. Dialogue System

## 5.2. DOTS

## 5.3. Multiplayer

# 6. Platforms and Technology
## 6.1. PC
### 6.1.1. Windows
### 6.1.2. Linux
### 6.1.3. Mac

## 6.2. WebGL

## 6.3. PlayStation

## 6.4. Xbox

## 6.5. Nintendo Switch

## 6.6. Phone

## 6.7. VR

## 6.8. AR

# 7. Debugging & Optimization
## 7.1. Profiling
- [ ] Unity Profiler
- [ ] Deep Profiling
- [ ] Custom Profiling Markers

## 7.2. Debugging
- [ ] Debug.Log / Debug.DrawLine
- [ ] Breakpoints
- [ ] Visual Studio Debugger
- [ ] Debugging Coroutines
- [ ] Physics Debugging
- [ ] Rendering Debug Views

## 7.3. Performance Optimization
- [ ] Memory Optimization
- [ ] Batching Optimization (SRP Batcher / Static & Dynamic Batching)
- [ ] Garbage Collection
- [ ] Boxing / Unboxing
- [ ] Object Pooling
- [ ] Script Execution Order
- [ ] Update vs FixedUpdate vs LateUpdate

## 7.4. Resource Management
### 7.4.1. Addressables
### 7.4.2. Asset Bundles
### 7.4.3. Assembly Definitions
### 7.4.3. IDisposable / Dispose

## 7.5. Testing
### 7.5.1. Unit Tests
### 7.5.2. Auto Tests
### 7.5.3. Benchmarks
### 7.5.4. Load Testing
### 7.5.5. Testing Tools
